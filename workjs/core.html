<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS CORE</title>
</head>

<body>
    <script>
        //<2023.08.31 목요일>
        //1.자바스크립트의 기본 데이터 타이들을 모두 쓰세요.
        //-숫자(number), 문자열(String), 불리언(Boolean), null, undefined, 객체(Object-배열,함수),
        ////bigint 심볼(Symbol) ->ECmAScript(표준안) 
        //null:값이 없음을 명시적으로 지정할 때 사용
        //undefined:값을 저장한 적이 없는 변수의 값  
        //"0"->String  {x:1, y:2}->object [1,2,3]->object funtion f(x){}->object
        //console.log(typeof null);->object
        //console.log(typeof function(){});->object

        //2.==연산자와 === 연사자의 차이를 쓰세요
        //  == : 비교대상들의 타입이 일치하지 않으면, 자동형변환하여 비교
        //  === : 비교대상들의 타입이 일치하지 않으면, 다르다고 판단
        // console.log(123 == '123');true
        // console.log(123 === '123');false
        // console.log(null == undefined);true
        // console.log(null === undefined);false
        //== 는 명시적으로 형변환을 하여, 타입이 일치하는 대상끼리 비교 권장
        //명시적으로 형변환할때, 타입이름으로 된 함수를 사용
        // console.log(String(123) == '123');true
        // console.log(123 == Number('123'));true

        //3.변수선언시 사용하는 var,let,const차이를 쓰세요
        //var x;    함수범위 변수
        //let x;    블록범위 변수
        //const x;  블록범위 상수        
        // if(true){
        //    var x =1;
        //    let y =2;
        //    console.log(x,y);
        // }
        // console.log(x);


        //4.아래 명령문에서 변수 c에 저장될 수 있는 값의 종류에 대해서 쓰세요.(논리연산자)
        // var c = a && b; a를 boolean으로 평가했을때, true면 결과값은 b, false면 결과값은 a
        // var c = a || b; a를 boolean으로 평가했을때, true면 결과값은 a, false면 결과값은 b
        //boolean으로 형변환시 false로 변환되는 값: 숫자-0,NaN(Not a Number),빈문자열'',null,undifined
        // console.log(1&&2);2
        // console.log(1||2);1
        // console.log('가나다'&&'마바사');마바사
        // console.log('가나다'||'마바사');가나다
        // console.log(Boolean('0'));// ->true
        // console.log(Boolean(' '));// ->true

        //5.prompt 숫자를 입력받아서 콘솔에 출력하는 프로그래을 작성하세요.
        //(숫자가 아닌 값을 입력하면 숫자를 입력할 때까지 반복합니다.)
        // alert():단순출력,confirm():참거짓입력,prompt():문자열입력
        // do{
        //      var v = prompt('숫자입력하세요');
        //      var n = Number(v); //숫자가 아닌값을 숫자로 변환하면 NaN
        // }while(isNaN(n)); //NaN 값 확인(비교)는 비교연산자가 아닌 isNaN() 함수 사용

        // console.log((n));

        //6.두 수의 합을 반환하는 함수 sum을 선언하세요.
        // console.log(sum(3,4));
        // function sum(x,y){
        // return x+y;
        // }

        // 1. var sum = new Function('x','y','return x+y;')
        //  console.log(sum(3,4));
        //      1 = 2
        // 2.var sum = function(x,y){
        //  return x+y
        // }
        // console.log(sum(3,4));

       // 화살표함수(람다식) :this,arguments가 없다
       // 1.function 키워드 대신 => 사용
       // 2.매개변수가 1개뿐이면 ()생략가능
       // 3.함수본문내용이 return 문 1개 뿐이라면,{return ;}생략가능
       var sum  = (x,y) => x+y;
        console.log(sum(3,4)); //->7
        console.log(sum(3,4,5));//->7
        console.log(sum(1,2,3,4));//->3
        console.log(sum(1,2,3,4,5,6));//->3

        // var sum = function(x,y){
        //  return x+y 
        // }

        // var x = 3;
        // var y = 4;
        // var sum = sum(x,y);
        // function sum(x,y){
        //  return x+y;
        // }
        //  console.log(sum);// 7 출력 -->

        //7.모든 인자들의 총합을 반환하는 함수 total을 선언하세요.
        //인자들의 갯수에 제한이 없음
        // function total(){//예전방법
        //     //함수 내에서 함수의 모든 인자값들을 담고 있는 arguments 유사배열 사용가능
        //     let n = 0;
        //     for(let i =0; i <arguments.length; i++){
        //         n += arguments[i];
        //     }   
        //     return n;
        // }

        // function total(...z){//나머지 매개변수를 배열로 받을 수 있다
        //     let n = 0;
        //     for(let i =0; i <z.length; i++){
        //         n += z[i];
        //     }   
        //     return n;
        // }


        //  console.log(total(3,4,5));// 12 출력
        //  console.log(total(1,2,3,4));// 10 출력
        //  console.log(total(1,2,3,4,5,6));// 21 출력

        //8. 정수 3,6,9,12,15 를 감은 배열 nums를 생성하세요.
        var nums = [3, 6, 9, 12, 15];
        // var nums = new Array(3, 6, 9, 12, 15);
        // var nums = Array(3, 6, 9, 12, 15);//가급적 사용x
         var nums = [];
         nums[0] =3;//[3]
         nums[1] =6;//[3,6]
         nums.push(9);//[3,6,9]
         nums.unshift(1);//[1,3,6,9]
         nums.shift(1);//[3,6,9]
         nums.push(15);//[3,6,9,15]
         nums.splice(3,0,12);//[3,6,9,12,15]
        console.log(nums);//[3,6,9,12,15]

        //nums 배열의 각 요소들을 ()로 감싸서 출력 (3),(6),(9),(12),(15)
        // for(let i = 0; i<nums.length; i ++){
        //     console.log('(',nums[i],')');
        //     console.log(`${nums[i]}`);//JSP -> EL처럼
        // }    

        // nums.forEach(function(v,i,arr){
        //     //배열의 요소,인덱스,배열을 인자로 전달하면서,요소 수만큼 반복실행
        //     console.log(`${nums[i]}`);
        //     console.log(`${arr[i]}`);
        //     console.log(`${[v]}`);
        //     console.log('('+ v +')');
        // });
        //람다식
        // nums.forEach(v=> console.log('('+ v +')'));
        // console.log(nums.toString());
        // console.log('('+ nums.join(')(')+')');


        //nums 배열의 각 요소에서 6을 뺀 값들을 담은 배열 nums2생성

        // var nums2 = [];
        // for (let i = 0; i < nums.length; i++) {
        //     nums2[i] =nums[i] - 6;
        //      nums2.push(nums[i]-6);           
        // }
        // var nums2 = nums.map(function(v,i,arr){
        //     return v -6;
        // });
        //람다식
        var nums2 = nums.map(v=>v-6);
        console.log(nums2);//[-3,0,3,6,9]

        //nums배열의 총합을 출력[3,6,9,12,15]
        // var n = 0;
        // for (let i = 0; i < nums.length; i++) {
        //     n += nums[i]; 
            
        // }  
        // var n = nums.reduce(function (preResult,v,i,arr) {
        //     //직전에 실행했던 함수의 반환값(결과값)을 첫번째 인자로 전달   
        //         return preResult +v;     
        // },0);//함수 최초 실행시 이전함수실행결과값으로 전달될 값을 지정
        
        // 람다식
       var n = nums.reduce((preResult,v)=>preResult+v,0);
        console.log(n); //45
     
        
    //<2023.09.04 월요일>
    // nums 배열의 요소에서 짝수인 요소만 담은 배열 nums3 생성
        // var nums3 =[];
        // for (let i = 0; i < nums.length; i++) {
        //     if(nums[i]%2===0){
        //        nums3.push( nums[i]);
        //     }
        // }
        // var nums3 = nums.filter(function(v,i,arr) {
        //     // if(v%2===0) return true;
        //     // else false;
        //     return v%2===0;
        // });

        //람다
        var nums3 = nums.filter(v=>v%2===0); 
        console.log(nums3);//[6,12]
    // nums 베열의 모든 요소가 0보다 크면 '양수', 그렇지 않으면 '정수' 출력
    // var flag = true;
    // for (let i = 0; i < nums.length; i++) {
    //     if( nums[i]<=0) 
    //         flag=false;
    //         break;
    // }
    // var flag = nums.every(function(v,i,arr){
    //     return v >0;
    // });
    var flag =nums.every((v)=>v>0);
    if(flag)console.log('양수');
    else console.log('정수');
    // nums2 베열의 모든 요소가 0보다 크면 '양수', 그렇지 않으면 '정수' 출력
    if(nums2.every((v)=>v>0)) console.log('양수');//[6,12]
    else console.log('정수');//[6,12]

    // nums 베열의 모든 요소들 중 0이 하나라도 있으면 '포함', 그렇지 않으면 '미포함' 출력
    // flag = false;
    // for (let i = 0; i < nums.length; i++) {
    //    if(nums[i]===0){
    //       flag = true;
    //       break;          
    //    }        
    // }
    // flag=nums.some(function (v,i,arr) {
    //     return v ===0;        
    // });
    //람다
    flag=nums.some(v=>v===0);
    if(flag)console.log('포함');
    else console.log('미포함');
    // nums2 베열의 모든 요소들 중 0이 하나라도 있으면 '포함', 그렇지 않으면 '미포함' 출력
    if(nums2.some(v=>v===0))console.log('포함');
    else console.log('미포함');

    //인자를 1개만 전달하면, 다른 인자의 값은 0으로 설정하여 결과를 출력하도록
    //함수sum을 재정의 하세요
    // sum = function(x,y=0){//함수 실행시 인자값을 받지못했을때 사용할 매개변수의 디폴트값 설정가능
    //      return x+y
    //     }

    // sum = function(x,y){
    //     if(y===undefined) y=0;//    y = y||0;
    //     return x+y
    // }
    var sum = (x,y=0)=>x+y;    
    console.log(sum(3));//3

   //객체 생성 방법
    // var obj = {};
    // var obj = new Object();
    // var obj = Object();//비추천
    // var obj = Object();//비추천
    // var obj = Object.create(Object.prototype);//,속성을담은객체);

    //9.
    //x속성값이 1이고, y속성값이 2이고,
    //좌표(x,y)와 원점(0,0)사이의 거리를 반환하는 dist() 메서드를 가진 객체를 변수 p에 저장
    //{속성명:속성값,속성명:속성값,....}
    // var p ={
    //     x:1,
    //     y:2,
    //     dist:function () {
    //       return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2));//x의 제곱값,y의 제곱값
    //     }   
    // };

    //객체 생성 후, 속성들을 자유롭게 추가,변경,삭제 가능
    // var p ={};
    //     p.x=1;
    //     p.y=2;
    //     p.dist=function () {
    //       return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2));//x의 제곱값,y의 제곱값
    //     };   

    //생성자 함수:객체생성을 위한 함수
    function Point(//x,y
    ) {
        this.x=1;
        this.y=2;
        this.dist=function () {
          return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2));//x의 제곱값,y의 제곱값
        }; 
    }
    //new 함수()->객체만들기
    //-새롭게 빈 객체({})를 생성하고
    //-그 객체를 this로 설정한 상태에서 함수를 실행한 후, 
    //-그 객체의 부모객체로 함수의 prototype 속성값을 설정하여,
    //-그 객체를 반환
     var p = new Point();

    // var p1 = new Point(1,2);
    // var p2 = new Point(3,4);
    // var p3 = new Point(5,6);
    
   
    //클래스 문법도 존재
    // class Point{
    //     x=1;
    //     y=2;
    //     dist() {
    //       return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2));//x의 제곱값,y의 제곱값
    //     }; 
    // }
    // var p = new Point();// 실제 동작은 생성자 함수랑 똑같이 동작함.

    //값 이외에 다양한 속성의 작동 방식을 설정하고 싶은 경우,
    // Object.create()명령문 사용 가능 
    // var p = Object.create(Object.prototype,{
    //     x:{value:1,writable:true}, 
    //     y:{value:2}})
       

    console.log(p.x);//1
    console.log(p.y);//2
    //객체의 속성 사용시, 객체.속성명 과 객체['속성명'] 표현 사용 가능->
    console.log(p['x']);//1
    console.log(p['y']);//2
    console.log(p.dist());//2.236...

    //객체 p의 모든 속성과 속성값들을 출력하세요.forof=>배열  forin =>객체안에 있는 속성들
    //for(let 변수 of 배열)//배열고 같이 반복가능한 데이터의 집합의 요소를 하나씩 변수에 저장하면서 반복
    for(let pname in p){//객체 p의 속성 이름을 pnmae에 저장하면서 반복
        console.log(pname,p[pname]);
    }

    var pobj = {a:1, b:2};
    var cobj = {b:3, c:4};
   // cobj.__proto__= pobj;//객체에는 부모객체를 저장하는 속성존재 
    Object.setPrototypeOf(cobj,pobj);//cobj객체의 부모객체로 pobj를 설정
    console.log(cobj.a,cobj.b,cobj.c);//1,3,4
    function Child(){
        this.b = 3;
        this.c = 4;
       // this..__proto__ = pobj;
      //Object.setPrototypeOf(this,pobj);
    }
    //생성자함수로 생성하는 객체들이 상속해야하는 부모객체를
    //생성자함수의 prototype 속성에 설정가능
    Child.prototype = pobj;
    var cobj1 = new Child();
    var cobj2 = new Child();
    console.log(cobj1.a,cobj1.b,cobj1.c);
    console.log(cobj2.a,cobj2.b,cobj2.c);


    //아래 코드를 실행하면, 주석 내용대로 출력되도록 코드를 작성하세요.
    function Car(m,s){
       this.model = m;
       this.speed = s;
    //    this.accel = function(){
    //         this.speed += 10;    
    //    };
    //    this.brake = function(){
    //         this.speed -= 10;    
    //    }
    }
    Car.prototype.accel = function(){
        this.speed += 10;
    };
    Car.prototype.brake = function(){
        this.speed -= 10;
    };

    // class Car{  
    //    constructor(m,s){
    //     this.model = m;
    //     this.speed = s;
    //    }
    //    accel(){
    //         this.speed += 10;    
    //    };
    //    brake(){
    //         this.speed -= 10;    
    //    }
    // }

    var c1 = new Car("Ray",60);
    console.log(c1.model);//"Ray"
    console.log(c1.speed);//"60"
    c1.accel();//속도가 10 증가
    console.log(c1.speed);//"70"
    c1.brake();//속도가 10 감소
    console.log(c1.speed);//"60" 
    var c2 = new Car("Soul",40);
    console.log(c2.model);//"Soul"
    console.log(c2.speed);//"40"
    c2.accel();//속도가 10 증가
    console.log(c2.speed);//"50"
    c2.brake();//속도가 10 감소
    console.log(c2.speed);//"40"

    //10.모든 객체에 tmi  메서드를 추가하세요
    //객체.tmi()메서드를 실행하면, 콘솔에 "제가 1994년 LA에 있었을 때"라고 출력
    Object.prototype.tmi = function(){
        console.log('제가 1994년 LA에 있었을 때');
    }
    p.tmi();//"제가 1994년 LA에 있었을때"
    cobj.tmi();//"제가 1994년 LA에 있었을때"
    ({}).tmi();//"제가 1994년 LA에 있었을때" // =new Object().tmi();
    
    //11.모든 배열에 remove메서드를 추가하세요.
    //배열.remove(1)메서들 실행하면 배열의 1번 요소를 삭제  
    Array.prototype.remove = function(i){
        this.splice(i,1);
    }
    nums.remove(2);
    console.log(nums);//[3,6,12,15]

    //12.모든 배열에 each,mymap 메서드를 추가하세요.
    //each 메서드는 forEach 메서드와 동일한 작업을 수행
    Array.prototype.each = function(f){
        // f = function(v,i,arr) {console.log('('+v+')');};
        for (let i = 0; i < this.length; i++) {
            // const element = array[i];  
            f(this[i],i,this);
        }
    };
    nums.each(v => console.log('('+v+')'));//(3),(6),(12),(15)
    nums.each(function(v,i,arr) {console.log('('+v+')');});


    Array.prototype.mymap = function(f){
        let result =[];
        // f = function(v,i,arr) {console.log('('+v+')');};
        for (let i = 0; i < this.length; i++) {
            result[i]= f(this[i],i,this);
        }
        return result;
    };
    console.log(nums.mymap(v => v-6));//[-3,0,6,9]

    var prodList = [];
    // {no:상품번호, name:상품명 price:정가, sale:할인율}
    prodList.push({no:1,name:'인디언밥',price: 500, sale:0.1});
    prodList.push({no:2,name:'고래밥',price: 800, sale:0.2});
    prodList.push({no:3,name:'사또밥',price: 200, sale:0.3});
    //prodList에 저장되어 있는 상품들의 '상품명'과 '할인된가격'을 콘솔에 출력
    console.log(prodList[0].name,prodList[0].price*(1-prodList[0].sale));
    console.log(prodList[1].name,prodList[1].price*(1-prodList[1].sale));
    console.log(prodList[2].name,prodList[2].price*(1-prodList[2].sale));
    
    for (let i = 0; i < prodList.length; i++) {
        const p = prodList[i];
        console.log(p.name,p.price*(1-p.sale));
    }

    for(var p of prodList)console.log(p.name,p.price*(1-p.sale));
    prodList.forEach(function(p,i,arr) {
        console.log(p.name,p.price*(1-p.sale));
    });

    prodList.forEach(p => console.log(p.name,p.price*(1-p.sale)));
   

    //'정가가 500이하인 상품들'의 '할인된 가격'의 총합을 출력
    var t = 0;
    for (let i = 0; i < prodList.length; i++) {
        const p = prodList[i];
        if(p.price<=500) t += p.price*(1-p.sale);
    }
    console.log(t);

        console.log(
            prodList.filter(p =>p.price<=500)   
            .map(p=> p.price*(1-p.sale))
            .reduce((pv,v,i,arr) => pv+v)
            );

    var studentList=[];
    studentList.push({no:'202301', rates:[5,4,3,4,5]});  
    studentList.push({no:'202302', rates:[5,5,2,5,5]});  
    studentList.push({no:'202303', rates:[4,3,3,3,5]});  
    studentList.push({no:'202304', rates:[5,4,1,4,5]});  
    studentList.push({no:'202305', rates:[3,4,3,4,3]});  

    //각 학생 객체에 rates를 100점 만점 점수로 환산한 결과를 담은 scores 속성 추가
    //각 학생 객체에 scores 값들의 총합을 저장하는 total 속성 추가
    for (let i = 0; i < studentList.length; i++) {
         const s = studentList[i];//{no:'202301', rates:[5,4,3,4,5]}
        // s.scores = [];
        // s.total = 0;
        // s.pass =true;
        // s.top = false;
        // for (let j = 0; j < s.rates.length; j++) {
        //         s.scores[j] = s.rates[j] * 20;               
        //         s.total += s.scores[j];  
        //         if(s.scores[j]<60) s.pass=false;         
        //         if(s.scores[j]>=90) s.top=true;         
        // }
        s.scores = s.rates.map(v=>v*20);
        s.total  = s.scores.reduce((pv,v)=>pv+v);  
        s.pass   = s.scores.every(v => v>=60);    
        s.top    = s.scores.some(v => v>=90);      
    }
    console.log(studentList);

   
    //각 학생 객체에 pass속성을 추가하고, scores에 60점 미만 점수가 없으면 true, 있으면 false설정
    //각 학생 객체에 top속성을 추가하고, scores에 90점 이상 점수가 없으면 true, 있으면 false설정

    



    </script>
</body>

</html>